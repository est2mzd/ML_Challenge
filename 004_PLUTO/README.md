# PLUTO: 
Contrastive Imitation Learning for Longitudinal-Lateral Coupling Decision-making in Urban Autonomous Driving

# 概要

## 1. 序論

### 1.1 背景と動機
この節では、都市部の自動運転車（AV）が直面する課題について説明しています。具体的には、複雑な交通状況や多様なエージェントの存在が、自動運転システムの計画と意思決定における大きな障壁となっていることが指摘されています。従来の手法では、特定の場面に適したルールベースのアプローチや、学習に基づくアプローチが存在するが、これらはそれぞれ限界を持っています。この論文では、模倣学習とコントラスト学習を組み合わせた新しい手法を提案し、これらの課題に対処します。

## 2. 関連研究

この章では、自動運転の分野における関連する研究をレビューしています。ルールベース、学習ベース、およびハイブリッド手法の利点と欠点が分析されています。また、模倣学習や強化学習の技術がどのように進化してきたかについても説明されています。

## 3. 手法

### 3.1 問題定式化
PLUTOのモデルは、AVが動的な都市環境で意思決定を行うための枠組みを提供します。具体的には、AVの周囲に存在する動的なエージェント、静的な障害物、高精度マップ、および交通信号の状態を考慮に入れています。これらの情報を元に、AVが将来の複数の軌道を生成し、シーンの文脈を統合して最適な軌道を選択します【21:5†source】。

### 3.2 入力表現とシーンエンコーディング
エージェントの履歴情報や静的障害物の特徴をエンコードするために、特徴ピラミッドネットワーク（FPN）を使用しています。これにより、エージェントの位置、方向、速度などの情報が効率的に抽出されます【21:5†source】。

### 3.3 軌道デコーディング
PLUTOは、横方向と縦方向の自己注意メカニズムを用いて、さまざまな軌道を生成します。最終的に、デコーダの出力を使用して、将来の軌道点とそれに関連するスコアを決定します【21:6†source】。

## 4. コントラスト模倣学習フレームワーク

### 4.1 フレームワークの概要
このフレームワークは、データ拡張とコントラスト学習を組み合わせて、モデルがより良い行動を学習できるように設計されています。具体的には、正のサンプルと負のサンプルを生成し、それらの間でコントラスト損失を計算することで、モデルの学習を強化します【21:16†source】。

### 4.2 データ拡張
状態の摂動や非相互作用エージェントの削除など、6つの拡張戦略が提案されています。これにより、モデルはさまざまなシナリオでの堅牢性を向上させます【21:12†source】。

## 5. 結果と考察

### 5.1 最先端技術との比較
PLUTOは、他の最先端の手法と比較して、さまざまな評価指標で優れた性能を示しています。特に、閉ループシナリオでの性能が向上しています【21:0†source】。

### 5.2 アブレーション研究
PLUTOの各コンポーネントの影響を分析するためのアブレーション研究が実施されています。これにより、状態ドロップアウトエンコーダーや補助損失が、モデルの性能向上に寄与していることが確認されています【21:18†source】。

## 6. 結論

この章では、PLUTOが自動運転分野における新しいベンチマークを設定し、学習ベースの計画における重要な進展を示していると結論付けています。今後の研究課題として、複数モードの予測を計画に統合する方法の探求が挙げられています【21:16†source】。

---

# 各章ごとに詳しくまとめる

# 1. 序論

## 1.1 背景と動機

学習ベースの計画（Learning-based planning）は、自動運転において拡張性のあるアプローチとして注目されており、多くの研究が行われています&#8203;:citation[oaicite:3]{index=3}&#8203;。特に、模倣学習に基づく計画は、シミュレーションや実世界の応用で成功を収めています。しかし、学習ベースの計画の効果はまだ不十分です。2023年のnuPlan計画チャレンジでは、従来のルールベースの計画が全ての学習ベースの代替手法を凌駕し、優勝しました。この論文では、学習ベースの計画における主要な課題を明らかにし、これらの課題に対処するための新しいソリューションを提案しています。

## 1.2 学習ベースの計画の課題

1. **マルチモーダル運転行動の取得**: 学習ベースのプランナーは、車線維持のような縦方向のタスクの学習に優れている一方で、車線変更や障害物の回避といった横方向のタスクには苦戦しています。この欠陥は、モデルの設計における明確な横方向行動モデリングの欠如に起因しています&#8203;:citation[oaicite:2]{index=2}&#8203;。

2. **純粋な模倣学習の限界**: 純粋な模倣学習には、学習のショートカットをとる傾向や、分布のシフト、因果混同などの問題が内在しています。特に、自動運転のような安全性が重要な領域では、トレーニング中に明示的な制約を課すことが不可欠です。本研究では、微分可能な補間に基づく新しい補助損失計算方法を導入し、これらの問題に対処します&#8203;:citation[oaicite:1]{index=1}&#8203;。

3. **新しいデータ拡張手法**: モデルがオープンループトレーニングとクローズドループテストを経る際に、時間とともにエラーが蓄積し、入力データがトレーニング分布から逸脱することがあります。データ拡張はこれらの問題を軽減するために広く用いられており、効果が証明されています。さらに、本研究では運転行動を調整し、相互作用の学習を強化するための新しい拡張手法を提案します&#8203;:citation[oaicite:0]{index=0}&#8203;。


# 2. 関連研究

## 2.1 模倣学習に基づく計画

模倣学習に基づく計画は、経験豊富なドライバーの政策をクローン化することにより、自動運転の最も直接的かつスケーラブルな解決策とされています。今日のデータの豊富さと経済性を考慮すると、この方法は非常に有望です。特に人気があるのはエンドツーエンド（E2E）運転のアプローチで、これは生センサーデータから直接運転政策を学習します。この手法は、比較的短期間で大きな進歩を遂げました。最初は、カメラ入力を制御政策にマッピングする畳み込みニューラルネットワーク（CNN）ベースのモデルに焦点が当てられていましたが【30:2†source】、その後、マルチセンサーフュージョンを活用したより高度な方法に進化しました【30:2†source】。

最近の開発では、LAVやUniADといった団体が主導し、モジュールベースのE2Eアーキテクチャにシフトしています。このアプローチは、認識、予測、計画のプロセスを統合したモデルを形成します。しかし、これらの多くのE2E戦略は、トレーニングと評価の両方で高忠実度のシミュレーション環境に大きく依存しています。その結果、シミュレーションされたエージェントのリアリズムと多様性の欠如、不完全なルールベースの専門家への依存、および現実世界での適用性のためのシミュレーションと現実のギャップを埋める必要性などの問題が生じています【30:2†source】【30:8†source】。

[LAV & UniAD](./Explanations/LAV_UniAD.md)

この論文では、事前認識結果を入力機能として使用する「ミッド・トゥ・ミッド」アプローチに焦点を当てています。この方法の主な利点は、シミュレーションから現実への転送の懸念を排除し、実世界のデータでモデルを計画の学習に集中させることができる点にあります。ChauffeurNet、SafetyNet、UrbanDriverなどの先駆的なアプローチは、実世界環境で自動運転車を操作する能力を示し、その後の研究はこれらの基盤の上に構築されてきました。これらのアプローチは、動作予測コミュニティにおける進展、特に予測タスクで優れた性能を発揮するベクトルベースのモデルの採用から大きな利益を得ています。しかし、これらのモデルの多くは、計画タスクに固有の特性、例えば閉ループテストや積極的な意思決定能力の必要性を見落としています。対照的に、我々の提案するフレームワークは、計画のために最初から設計されています。ネットワークは、クエリベースのアーキテクチャを通じて縦方向と横方向の運転行動を共同でモデル化し、柔軟で多様な運転スタイルを可能にしています【30:2†source】。

## 2.2 対照学習

対照学習は、類似したペアと異なるペアを比較することで表現を学習するフレームワークであり、コンピュータビジョンや自然言語処理で大きな成功を収めています。自動運転の文脈では、運動予測のためのいくつかの試みがなされています。Social NCEは、歩行者の動きの予測において目標生成を導くために社会的対照損失を導入しました。Marahらは、学習された軌道埋め込みを洗練するためにアクションベースの対照学習損失を利用しました。FENDはこのアプローチを使用してロングテール軌道を認識しました。これらの研究は、正と負の例の慎重な選択を通じてモデルにドメイン固有の知識を組み込む上での対照学習の力を強調しています【30:8†source】。



# 3. Methodology（手法）

[数式の詳細解説](./Explanations/Sec3_Equation.md)

## 3.1 Problem Formulation（問題定式化）

本研究では、動的な都市環境における自動運転車（AV）の計画タスクを探求しています。このシステムは、AV、動的エージェント、静的障害物、高精度マップ、および交通信号の状態を考慮に入れています。エージェントの特徴は \(A = A_0:NA\) と定義され、ここで \(A_0\) はAV、静的障害物は \(O = O_1:NS\) で表されます。エージェントの未来の状態を時間 \(t\) における \(y^t_a\) とし、履歴と未来の時間範囲は \(TH\) と \(TF\) で表されます。PLUTOは、AVのために複数のモーダル計画軌道を同時に生成し、各動的エージェントの予測を行います。最終的な出力軌道 \(\tau^*\) の選択は、学習ベースの結果をシーンの文脈と統合するスコアリングモジュール \(S\) によって行われます【18†source】。

\[
(T_0, \pi_0), P_{1:NA} = f(A, O, M, C | \phi)
\]

\[
(\tau^*, \pi^*) = \arg\max_{(\tau, \pi) \in (T_0, \pi_0)} S(\tau, \pi, P_{1:NA}, O, M, C)
\]

ここで、\(f\) はPLUTOのニューラルネットワーク、\(\phi\) はモデルパラメータ、\((T_0, \pi_0)\) はAVの計画軌道とそれに対応する信頼度スコア、\(P_{1:NA}\) はエージェントの予測を表します。

## 3.2 Input Representation and Scene Encoding（入力表現とシーンエンコーディング）

**Agent History Encoding（エージェントの履歴エンコーディング）**  
各エージェントの観測状態は時間 \(t\) において \(s^t_i = (p^t_i, \theta^t_i, v^t_i, b^t_i, I^t_i)\) として表されます。ここで、\(p\) と \(\theta\) はエージェントの位置座標と方向角を表し、\(v\) は速度ベクトル、\(b\) は認識バウンディングボックスの寸法（長さと幅）、\(I\) は観測状態を示すバイナリ指標です。履歴シーケンスは、連続する時間ステップ間の差分を計算してベクトル形式に変換されます【18†source】。

\[
\hat{s}^t_i = (p^t_i - p^{t-1}_i, \theta^t_i - \theta^{t-1}_i, v^t_i - v^{t-1}_i, b^t_i, I^t_i)
\]

これにより、エージェントの特徴ベクトル \(F_A \in \mathbb{R}^{N_A \times (T_H-1) \times 8}\) が得られます。これらの履歴特徴を抽出して凝縮するために、近隣注意ベースの特徴ピラミッドネットワーク（FPN）を使用し、エージェントの埋め込み \(E_A \in \mathbb{R}^{N_A \times D}\) を生成します【18†source】。

**Static Obstacles Encoding（静的障害物のエンコーディング）**  
静的障害物は、AVが通過してはならないすべてのエンティティを指し、例えば、交通コーンやバリアなどがあります。各静的障害物は、\(o_i = (p_i, \theta_i, b_i)\) として表されます。静的オブジェクトの特徴 \(F_O \in \mathbb{R}^{N_S \times 5}\) をエンコードするために、2層の多層パーセプトロン（MLP）を使用し、埋め込み \(E_O \in \mathbb{R}^{N_S \times D}\) を生成します【18†source】。

**AV's State Encoding（AVの状態エンコーディング）**  
過去の研究に基づき、模倣学習は履歴状態からショートカットを採用する傾向があり、性能に悪影響を与えることが示されています。本アプローチでは、AVの現在の状態のみを入力特徴として利用します。この現在の状態には、AVの位置、方向角、速度、加速度、ステアリング角が含まれます。状態特徴をエンコードするために、注意ベースの状態ドロップアウトエンコーダー（SDE）を使用し、AVの埋め込み \(E_{AV} \in \mathbb{R}^{1 \times D}\) を生成します【18†source】。

**Vectorized Map Encoding（ベクトル化マップのエンコーディング）**  
マップは \(N_P\) のポリラインで構成されます。これらのポリラインは、ポイントの数を標準化するために初期サンプリングが行われ、その後、各ポイントの特徴ベクトルが計算されます。具体的には、各ポリラインの \(i\) 番目のポイントの特徴は、8つのチャンネルで構成されます【18†source】。

\[
(p_i - p_0, p_i - p_{i-1}, p_i - p_{left_i}, p_i - p_{right_i})
\]

ここで、\(p_0\) はポリラインの初期ポイント、\(p_{left_i}\) と \(p_{right_i}\) はレーンの左および右の境界ポイントを表します。ポリラインの特徴は \(F_P \in \mathbb{R}^{N_P \times n_p \times 8}\) で表され、マップ特徴をエンコードするためにPointNetに似たポリラインエンコーダーを使用し、エンコードされた特徴空間 \(E_P \in \mathbb{R}^{N_P \times D}\) を生成します【18†source】。

**Scene Encoding（シーンエンコーディング）**  
さまざまなモーダル入力間の複雑な相互作用を効果的にキャプチャするために、異なる埋め込みを単一のテンソル \(E_0 \in \mathbb{R}^{(N_A + N_S + N_P + 1) \times D}\) に連結します。このテンソルは、その後、\(L_{enc}\) のトランスフォーマーエンコーダーのシリーズを使用して統合されます【18†source】。

\[
E_0 = \text{concat}(E_{AV}, E_A, E_O, E_P) + PE + E_{attr}
\]

ここで、\(PE\) はグローバル位置のフーリエ埋め込みを表し、\(E_{attr}\) はエージェントのタイプやレーンの制限速度、交通信号の状態などの意味属性をエンコードするための学習可能な埋め込みです。トランスフォーマーエンコーダーの \(i\) 番目の層は次のように定式化されます【18†source】。

\[
\hat{E}^{i-1} = \text{LayerNorm}(E^{i-1})
\]

\[
E^i = E^{i-1} + \text{MHA}(\hat{E}^{i-1}, \hat{E}^{i-1}, \hat{E}^{i-1})
\]

\[
E^i = E^i + \text{FFN}(\text{LayerNorm}(E^i))
\]

ここで、\(\text{MHA}(q, k, v)\) は標準的なマルチヘッドアテンション関数を表し、FFNはフィードフォワードネットワーク層を表します。エンコーダの最終層の出力を \(E_{enc}\) とします【18†source】。

## 3.3 Multi-modal Planning Trajectory Decoding（マルチモーダル計画軌道デコーディング）

自動運転の計画タスクは本質的にマルチモーダルであり、与えられた運転シナリオに応じて複数の有効な行動が存在することが多いです。たとえば、車両は前方の遅い車両に追従し続けるか、レーンを変更して追い越すことができます。この複雑な問題に対処するために、クエリベースのDETRライクな軌道デコーダを使用します。しかし、学習したアンカーフリーのクエリを直接実装すると、モード崩壊やトレーニングの不安定性を引き起こすことが分かっています。運転行動は横方向（例：レーン変更）と縦方向（例：ブレーキ、加速）の組み合わせに分解できるという観察に基づき、半アンカーベースのデコーディング構造を導入します【18†source】。

**Reference Lines as Lateral Queries（横方向クエリとしての参照線）**  
参照線は、横方向クエリのための高レベルの抽象化として機能します。参照線は、通常、AVのルート周辺のレーンから導かれ、横方向の運転行動を導くために使用されます。参照線の特徴の表現とエンコーディングの方法は、ベクトル化マップエンコーディングと同様です。最終的に、埋め込まれた参照線は、横方向のクエリ \(Q_{lat} \in \mathbb{R}^{N_R \times D}\) として使用されます【18†source】。

**Factorized Lateral-longitudinal Self-Attention（ファクタライズド横縦方向自己注意）**  
横方向クエリ \(Q_{lat}\) に加えて、複数のモーダルの縦方向行動をキャプチャするために、アンカーフリーの学習可能なクエリ \(Q_{lon} \in \mathbb{R}^{N_L \times D}\) を使用します。次に、\(Q_{lat}\) と \(Q_{lon}\) を組み合わせて、初期の横縦方向クエリのセット \(Q_0 \in \mathbb{R}^{N_R \times N_L \times D}\) を作成します【18†source】。

\[
Q_0 = \text{Projection}(\text{concat}(Q_{lat}, Q_{lon}))
\]

ここで、Projectionは単純な線形層または多層パーセプトロンを指します。横方向の自己注意メカニズムを使用して、さまざまな参照線間でグローバルな横縦方向の情報を統合します【18†source】。

**Trajectory Decoding（軌道デコーディング）**  
軌道デコーダは、横方向自己注意、縦方向自己注意、クエリからシーンへのクロスアテンションの3つの注意メカニズムで構成される一連のデコーディング層からなります。これらのプロセスは、次のように数学的に表現されます【18†source】。

\[
Q'_{i-1} = \text{SelfAttn}(Q_{i-1}, \text{dim} = 0)
\]

\[
\hat{Q}_{i-1} = \text{SelfAttn}(Q'_{i-1}, \text{dim} = 1)
\]

\[
Q_i = \text{CrossAttn}(\hat{Q}_{i-1}, E_{enc}, E_{enc})
\]

ここで、\(\text{SelfAttn}(X, \text{dim} = i)\) は \(X\) の \(i\) 次元に対する自己注意を適用することを示し、\(\text{CrossAttn}(Q, K, V)\) はレイヤーノーマライゼーション、マルチヘッドアテンション、およびフィードフォワードネットワークを含みます【18†source】。

最終的にデコーダの出力 \(Q_{dec}\) を使用して、AVの将来の軌道点とそれに対応するスコアを2つのMLPを用いて決定します【18†source】。

\[
T_0 = \text{MLP}(Q_{dec}), \quad \pi_0 = \text{MLP}(Q_{dec})
\]
